<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Interactive K-Means Demo</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body { font-family: sans-serif; display: flex; justify-content: center; align-items: flex-start; margin-top: 20px;}
        .controls { margin-left: 30px; width: 250px;}
        .control-group { margin-bottom: 20px; }
        svg { border: 1px solid #ccc; }
        button { font-size: 16px; padding: 5px 10px; margin-right: 5px; cursor: pointer;}
        label { display: block; margin-bottom: 5px; }
        #iteration-counter { font-weight: bold; }
    </style>
</head>
<body>
    <div id="visualization"></div>
    <div class="controls">
        <div class="control-group">
            <h3>Controls</h3>
            <button id="reset-btn">Re-initialize</button>
            <button id="step-btn">Step</button>
            <button id="run-btn">Run</button>
        </div>
        <div class="control-group">
             <label for="k-slider">Number of Clusters (K): <span id="k-value">3</span></label>
             <input type="range" id="k-slider" min="2" max="8" value="3">
        </div>
        <div class="control-group">
            <h3>Status</h3>
            <p>Iteration: <span id="iteration-counter">0</span></p>
            <p id="status-text">Initialized. Ready to start.</p>
        </div>
    </div>

    <script>
        const margin = { top: 20, right: 20, bottom: 30, left: 40 };
        const width = 500 - margin.left - margin.right;
        const height = 500 - margin.top - margin.bottom;

        let k = 3;
        let data, centroids, assignments;
        let iteration = 0;
        let running = false;
        let interval;

        const svg = d3.select("#visualization")
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const xScale = d3.scaleLinear().domain([0, 100]).range([0, width]);
        const yScale = d3.scaleLinear().domain([0, 100]).range([height, 0]);
        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);

        function generateData() {
            const n = 200;
            const clusters = [
                { x: 25, y: 30, count: 70 },
                { x: 70, y: 75, count: 70 },
                { x: 30, y: 80, count: 60 }
            ];
            const points = [];
            clusters.forEach(cluster => {
                for (let i = 0; i < cluster.count; i++) {
                    points.push({
                        x: d3.randomNormal(cluster.x, 10)(),
                        y: d3.randomNormal(cluster.y, 10)()
                    });
                }
            });
            return points;
        }

        function initialize() {
            iteration = 0;
            running = false;
            clearInterval(interval);
            
            data = generateData();
            centroids = [];
            for (let i = 0; i < k; i++) {
                centroids.push({
                    x: Math.random() * 100,
                    y: Math.random() * 100
                });
            }
            assignments = new Array(data.length);
            updateStatus("Initialized. Ready to start.");
            draw();
        }
        
        function distance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        function assignmentStep() {
            let changed = false;
            data.forEach((point, i) => {
                let min_dist = Infinity;
                let best_centroid = -1;
                centroids.forEach((centroid, j) => {
                    const dist = distance(point, centroid);
                    if (dist < min_dist) {
                        min_dist = dist;
                        best_centroid = j;
                    }
                });
                if (assignments[i] !== best_centroid) {
                    changed = true;
                }
                assignments[i] = best_centroid;
            });
            return changed;
        }

        function updateStep() {
            const new_centroids = [];
            const counts = new Array(k).fill(0);
            const sums = new Array(k).fill(0).map(() => ({ x: 0, y: 0 }));

            data.forEach((point, i) => {
                const c_index = assignments[i];
                if(c_index !== undefined){
                    counts[c_index]++;
                    sums[c_index].x += point.x;
                    sums[c_index].y += point.y;
                }
            });

            for (let i = 0; i < k; i++) {
                if (counts[i] > 0) {
                    new_centroids[i] = { x: sums[i].x / counts[i], y: sums[i].y / counts[i] };
                } else {
                    // Re-initialize centroid if it has no points
                    new_centroids[i] = { x: Math.random() * 100, y: Math.random() * 100 };
                }
            }
            centroids = new_centroids;
        }

        function step() {
            if (running) return;
            iteration++;
            updateStatus("Assigning points to closest centroids...");
            const changed = assignmentStep();
            draw();

            setTimeout(() => {
                if (!changed) {
                    updateStatus("Converged! Centroids are stable.");
                    running = false;
                    clearInterval(interval);
                    return;
                }
                updateStatus("Updating centroid positions...");
                updateStep();
                draw();
            }, 500);
        }

        function run() {
            if (running) return;
            running = true;
            interval = setInterval(() => {
                iteration++;
                updateStatus("Assigning points...");
                const changed = assignmentStep();
                draw();

                if (!changed) {
                    updateStatus("Converged! Centroids are stable.");
                    running = false;
                    clearInterval(interval);
                    return;
                }
                
                updateStatus("Updating centroids...");
                updateStep();
                draw();

            }, 1000);
        }

        function draw() {
            // Data points
            const points = svg.selectAll("circle")
                .data(data);
            
            points.enter()
                .append("circle")
                .attr("r", 5)
                .merge(points)
                .transition().duration(300)
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.y))
                .attr("fill", (d, i) => assignments[i] === undefined ? "#ccc" : colorScale(assignments[i]));

            // Centroids
            const centroidShapes = svg.selectAll("rect")
                .data(centroids);

            centroidShapes.enter()
                .append("rect")
                .attr("width", 10)
                .attr("height", 10)
                .attr("stroke", "#000")
                .attr("stroke-width", 2)
                .merge(centroidShapes)
                .transition().duration(300)
                .attr("x", d => xScale(d.x) - 5)
                .attr("y", d => yScale(d.y) - 5)
                .attr("fill", (d, i) => colorScale(i));

            d3.select("#iteration-counter").text(iteration);
        }
        
        function updateStatus(text) {
            d3.select("#status-text").text(text);
        }

        // Event Listeners
        d3.select("#reset-btn").on("click", initialize);
        d3.select("#step-btn").on("click", step);
        d3.select("#run-btn").on("click", run);
        d3.select("#k-slider").on("input", function() {
            k = +this.value;
            d3.select("#k-value").text(k);
            initialize();
        });

        // Initial setup
        initialize();

    </script>
</body>
</html>
