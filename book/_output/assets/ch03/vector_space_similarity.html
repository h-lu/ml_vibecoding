<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>向量空间：相似度（距离）交互演示</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Liberation Sans', sans-serif; margin: 0; }
    .wrap { max-width: 1200px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 20px; margin: 0 0 8px; }
    .sub { color:#555; margin-bottom: 14px; font-size: 14px; }
    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; align-items: center; }
    .ctrl { background: #f7f7f9; border: 1px solid #e3e3e7; border-radius: 10px; padding: 10px 12px; }
    .ctrl label { display: block; font-size: 13px; color: #333; margin-bottom: 6px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    select { padding: 6px 8px; border-radius: 6px; border: 1px solid #ccc; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #eef; border: 1px solid #ccf; font-size: 12px; }
    #scatter { width: 100%; height: 520px; }
    .stats { font-size: 13px; color: #333; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>向量空间：相似度（距离）交互演示</h1>
    <div class="sub">点击客户（圆点）或拖动理想客户（星形）以更新连线与“最近邻”；切换“距离度量”比较欧氏距离与余弦距离的差异。</div>

    <div class="controls">
      <div class="ctrl">
        <label>距离度量：<span id="metricBadge" class="badge"></span></label>
        <div class="row">
          <select id="metric">
            <option value="euclidean">欧氏距离</option>
            <option value="manhattan">曼哈顿距离 (L1)</option>
            <option value="chebyshev">切比雪夫距离 (L∞)</option>
            <option value="minkowski">闵可夫斯基距离 (Lp)</option>
            <option value="seuclidean">标准化欧氏距离</option>
            <option value="mahalanobis">马氏距离</option>
            <option value="cosine">余弦距离</option>
          </select>
        </div>
      </div>
      <div class="ctrl" id="ctrlMinkowski" style="display:none;">
        <label>Minkowski 幂指数 p：<span id="pBadge" class="badge"></span></label>
        <div class="row"><input id="minkowskiP" type="range" min="0.5" max="6" step="0.1"></div>
      </div>
      <div class="ctrl">
        <label>距离可视化</label>
        <div class="row">
          <label><input id="showIso" type="checkbox" checked> 显示等距曲线/角度</label>
        </div>
      </div>
      <div class="ctrl">
        <label>当前统计</label>
        <div class="row"><div id="stats" class="stats"></div></div>
      </div>
    </div>

    <div id="scatter"></div>
  </div>

  <script>
    // 简单的二维客户数据（每月访问次数、平均学习时长），0-10 归一化到 0-1 便于可视化
    const CUSTOMERS = [
      { id: 'A', x: 0.2, y: 0.8 },
      { id: 'B', x: 0.9, y: 0.7 },
      { id: 'C', x: 0.1, y: 0.2 },
      { id: 'D', x: 0.5, y: 0.6 },
      { id: 'E', x: 0.7, y: 0.1 },
      { id: 'F', x: 0.35, y: 0.25 }
    ];

    const UI = {
      metric: document.getElementById('metric'),
      metricBadge: document.getElementById('metricBadge'),
      stats: document.getElementById('stats'),
      ctrlMinkowski: document.getElementById('ctrlMinkowski'),
      minkowskiP: document.getElementById('minkowskiP'),
      pBadge: document.getElementById('pBadge'),
      showIso: document.getElementById('showIso')
    };

    const state = {
      metric: 'euclidean',
      ideal: { x: 0.6, y: 0.6 },
      selectedId: null,
      showIso: true,
      minkowskiP: 3
    };

    // 统计信息（用于标准化欧氏与马氏距离）
    const Stats = (function computeStats() {
      const xs = CUSTOMERS.map(c => c.x);
      const ys = CUSTOMERS.map(c => c.y);
      const mean = { x: xs.reduce((a,b)=>a+b,0)/xs.length, y: ys.reduce((a,b)=>a+b,0)/ys.length };
      const vx = xs.reduce((s,v)=>s+(v-mean.x)*(v-mean.x),0)/Math.max(1,xs.length-1);
      const vy = ys.reduce((s,v)=>s+(v-mean.y)*(v-mean.y),0)/Math.max(1,ys.length-1);
      const covxy = xs.reduce((s,_,i)=>s+(xs[i]-mean.x)*(ys[i]-mean.y),0)/Math.max(1,xs.length-1);
      // 协方差矩阵与正则化
      const lam = 1e-6;
      const S = [[vx+lam, covxy],[covxy, vy+lam]];
      const invS = invert2x2(S);
      const cholS = chol2x2(S);
      const std = { x: Math.sqrt(vx+lam), y: Math.sqrt(vy+lam) };
      return { mean, S, invS, cholS, std };
    })();

    function invert2x2(M) {
      const a=M[0][0], b=M[0][1], c=M[1][0], d=M[1][1];
      const det = a*d - b*c;
      if (Math.abs(det) < 1e-12) {
        const eps = 1e-6;
        return [[1/eps,0],[0,1/eps]];
      }
      const invDet = 1/det;
      return [[ d*invDet, -b*invDet], [ -c*invDet, a*invDet ]];
    }

    function chol2x2(S) {
      // S 是对称正定，返回下三角 L，满足 S = L L^T
      const a = S[0][0], b = S[0][1], c = S[1][1];
      const L11 = Math.sqrt(Math.max(a, 1e-12));
      const L21 = b / L11;
      const t = c - L21*L21;
      const L22 = Math.sqrt(Math.max(t, 1e-12));
      return [[L11, 0],[L21, L22]];
    }

    function distEuclidean(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      return Math.hypot(dx, dy);
    }
    function distCosine(a, b) {
      const dot = a.x*b.x + a.y*b.y;
      const na = Math.hypot(a.x, a.y);
      const nb = Math.hypot(b.x, b.y);
      if (na === 0 || nb === 0) return 1; // 定义：零向量与任何向量的余弦距离为 1
      const cos = dot / (na * nb);
      return 1 - Math.max(-1, Math.min(1, cos));
    }
    function distManhattan(a, b) {
      return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
    }
    function distChebyshev(a, b) {
      return Math.max(Math.abs(a.x - b.x), Math.abs(a.y - b.y));
    }
    function distMinkowski(a, b, p) {
      const dx = Math.abs(a.x - b.x), dy = Math.abs(a.y - b.y);
      const pp = Math.max(0.5, p);
      return Math.pow(Math.pow(dx, pp) + Math.pow(dy, pp), 1/pp);
    }
    function distSEuclidean(a, b) {
      const dx = (a.x - b.x) / Stats.std.x;
      const dy = (a.y - b.y) / Stats.std.y;
      return Math.hypot(dx, dy);
    }
    function distMahalanobis(a, b) {
      const dx = a.x - b.x, dy = a.y - b.y;
      const v0 = dx*Stats.invS[0][0] + dy*Stats.invS[1][0];
      const v1 = dx*Stats.invS[0][1] + dy*Stats.invS[1][1];
      const d2 = dx*v0 + dy*v1;
      return Math.sqrt(Math.max(0, d2));
    }
    function metricFn() {
      switch (state.metric) {
        case 'euclidean': return distEuclidean;
        case 'manhattan': return distManhattan;
        case 'chebyshev': return distChebyshev;
        case 'minkowski': return (a,b)=>distMinkowski(a,b,state.minkowskiP);
        case 'seuclidean': return distSEuclidean;
        case 'mahalanobis': return distMahalanobis;
        case 'cosine': return distCosine;
        default: return distEuclidean;
      }
    }

    function nearestNeighbor() {
      const d = metricFn();
      let best = null, bestVal = Infinity;
      for (const c of CUSTOMERS) {
        const v = d(c, state.ideal);
        if (v < bestVal) { bestVal = v; best = c; }
      }
      return { best, bestVal };
    }

    function fmt(x) { return x.toFixed(3); }

    function draw() {
      UI.metricBadge.textContent = state.metric === 'euclidean' ? '欧氏距离' : '余弦距离';
      if (state.metric === 'minkowski') {
        UI.ctrlMinkowski.style.display = '';
        UI.pBadge.textContent = state.minkowskiP.toFixed(1);
        UI.minkowskiP.value = state.minkowskiP;
      } else {
        UI.ctrlMinkowski.style.display = 'none';
      }

      const d = metricFn();
      const xs = CUSTOMERS.map(c => c.x);
      const ys = CUSTOMERS.map(c => c.y);
      const texts = CUSTOMERS.map(c => `客户 ${c.id}`);

      const customerTrace = {
        x: xs, y: ys, mode: 'markers+text', type: 'scatter', name: '客户',
        marker: { size: 10, color: '#1f77b4', line: { width: 0.5, color: '#333' }, opacity: 0.9 },
        text: CUSTOMERS.map(c => c.id), textposition: 'top center',
        hovertemplate: '客户 %{text}<br>x=%{x:.2f}, y=%{y:.2f}<extra></extra>'
      };

      // 比较对象：优先所选客户，否则用最近邻
      const { best, bestVal } = nearestNeighbor();
      const cmp = state.selectedId ? CUSTOMERS.find(c => c.id === state.selectedId) : best;
      const cmpDist = d(cmp, state.ideal);
      const connTrace = {
        x: [cmp.x, state.ideal.x], y: [cmp.y, state.ideal.y], mode: 'lines+markers', type: 'scatter', name: '距离连线',
        line: { width: 2, color: '#9467bd', dash: 'dot' }, marker: { size: 4, color: '#9467bd' }, hoverinfo: 'skip'
      };
      const connText = {
        x: [(cmp.x + state.ideal.x) / 2], y: [(cmp.y + state.ideal.y) / 2], mode: 'text', type: 'scatter',
        text: [`d = ${fmt(cmpDist)}`], textposition: 'top center', showlegend: false, hoverinfo: 'skip'
      };

      // 最近邻高亮
      const bestTrace = {
        x: [best.x], y: [best.y], mode: 'markers', type: 'scatter', name: '最相似客户',
        marker: { size: 14, color: '#2ca02c', symbol: 'diamond', line: { width: 1, color: '#333' } },
        hovertemplate: '最相似客户<br>x=%{x:.2f}, y=%{y:.2f}<extra></extra>'
      };

      // 等距曲线/角度可视化
      const isoTraces = state.showIso ? makeIsoTraces(state.metric, cmpDist, state.ideal, cmp) : [];

      const layout = {
        title: '相似度（距离）可视化：欧氏 vs 余弦',
        xaxis: { title: '每月访问（归一化）', range: [-0.05, 1.05], zeroline: false },
        yaxis: { title: '平均学习时长（归一化）', range: [-0.05, 1.05], scaleanchor: 'x', scaleratio: 1, zeroline: false },
        margin: { l: 60, r: 20, t: 40, b: 40 },
        showlegend: true,
        annotations: [
          {
            xref: 'x', yref: 'y', x: state.ideal.x, y: state.ideal.y,
            text: '★', showarrow: false, font: { size: 22, color: '#e74c3c' },
            captureevents: true
          }
        ]
      };

      const traces = [customerTrace, bestTrace, connTrace, connText, ...isoTraces];
      Plotly.react('scatter', traces, layout, {
        displayModeBar: false,
        scrollZoom: false,
        doubleClick: 'reset',
        editable: true,
        edits: { annotationPosition: true }
      });

      const metricLabelMap = { euclidean:'欧氏', manhattan:'曼哈顿(L1)', chebyshev:'切比雪夫(L∞)', minkowski:`闵可夫斯基(p=${state.minkowskiP.toFixed(1)})`, seuclidean:'标准化欧氏', mahalanobis:'马氏', cosine:'余弦' };
      UI.stats.textContent = `当前度量 = ${metricLabelMap[state.metric]} ｜ 最相似客户 = ${best.id} ｜ 距离 = ${fmt(bestVal)}${state.selectedId ? ` ｜ 所选客户 ${state.selectedId} 距离 = ${fmt(cmpDist)}` : ''}`;
    }

    function makeIsoTraces(metric, distVal, center, compare) {
      if (!isFinite(distVal) || distVal <= 0) return [];
      const traces = [];
      const N = 256;
      function close(x,y){ if (x.length>0){ x.push(x[0]); y.push(y[0]); } }
      if (metric === 'euclidean') {
        const xs=[], ys=[];
        for (let i=0;i<N;i++){ const t=2*Math.PI*i/(N-1); xs.push(center.x + distVal*Math.cos(t)); ys.push(center.y + distVal*Math.sin(t)); }
        close(xs,ys);
        traces.push({ x: xs, y: ys, mode:'lines', type:'scatter', name:'等距曲线', line:{width:1.5, color:'rgba(31,119,180,0.55)', dash:'solid'}, hoverinfo:'skip' });
      } else if (metric === 'manhattan') {
        const xs=[center.x+distVal, center.x, center.x-distVal, center.x, center.x+distVal];
        const ys=[center.y, center.y+distVal, center.y, center.y-distVal, center.y];
        traces.push({ x: xs, y: ys, mode:'lines', type:'scatter', name:'等距曲线', line:{width:1.5, color:'rgba(31,119,180,0.55)'}, hoverinfo:'skip' });
      } else if (metric === 'chebyshev') {
        const d=distVal; const xs=[center.x-d, center.x+d, center.x+d, center.x-d, center.x-d];
        const ys=[center.y-d, center.y-d, center.y+d, center.y+d, center.y-d];
        traces.push({ x: xs, y: ys, mode:'lines', type:'scatter', name:'等距曲线', line:{width:1.5, color:'rgba(31,119,180,0.55)'}, hoverinfo:'skip' });
      } else if (metric === 'minkowski') {
        const p = Math.max(0.5, state.minkowskiP);
        const xs=[], ys=[];
        for (let i=0;i<N;i++){
          const t=2*Math.PI*i/(N-1);
          const c=Math.cos(t), s=Math.sin(t);
          const r = distVal / Math.pow(Math.pow(Math.abs(c),p)+Math.pow(Math.abs(s),p), 1/p);
          xs.push(center.x + r*c); ys.push(center.y + r*s);
        }
        close(xs,ys);
        traces.push({ x: xs, y: ys, mode:'lines', type:'scatter', name:'等距曲线', line:{width:1.5, color:'rgba(31,119,180,0.55)'}, hoverinfo:'skip' });
      } else if (metric === 'seuclidean') {
        const xs=[], ys=[]; const sx=Stats.std.x, sy=Stats.std.y;
        for (let i=0;i<N;i++){ const t=2*Math.PI*i/(N-1); xs.push(center.x + distVal*sx*Math.cos(t)); ys.push(center.y + distVal*sy*Math.sin(t)); }
        close(xs,ys);
        traces.push({ x: xs, y: ys, mode:'lines', type:'scatter', name:'等距曲线', line:{width:1.5, color:'rgba(31,119,180,0.55)'}, hoverinfo:'skip' });
      } else if (metric === 'mahalanobis') {
        // x = center + dist * L * u, 其中 S = L L^T，u 是单位圆
        const xs=[], ys=[]; const L=Stats.cholS; // 2x2
        for (let i=0;i<N;i++){
          const t=2*Math.PI*i/(N-1); const u=[Math.cos(t), Math.sin(t)];
          const dx = distVal*(L[0][0]*u[0] + L[0][1]*u[1]);
          const dy = distVal*(L[1][0]*u[0] + L[1][1]*u[1]);
          xs.push(center.x + dx); ys.push(center.y + dy);
        }
        close(xs,ys);
        traces.push({ x: xs, y: ys, mode:'lines', type:'scatter', name:'等距曲线', line:{width:1.5, color:'rgba(31,119,180,0.55)'}, hoverinfo:'skip' });
      } else if (metric === 'cosine') {
        // 余弦距离：用两条从原点出发的射线 + 夹角弧线表示
        const o = {x:0, y:0};
        const nI = Math.hypot(center.x, center.y); const nC = Math.hypot(compare.x, compare.y);
        if (nI>1e-6 && nC>1e-6) {
          const uI = { x: center.x/nI, y: center.y/nI };
          const uC = { x: compare.x/nC, y: compare.y/nC };
          const a1 = Math.atan2(uI.y, uI.x), a2 = Math.atan2(uC.y, uC.x);
          function angleDiff(a,b){ let d=a-b; while(d>Math.PI) d-=2*Math.PI; while(d<-Math.PI) d+=2*Math.PI; return d; }
          const dAng = angleDiff(a2,a1);
          const steps = Math.max(16, Math.floor(Math.abs(dAng) / (Math.PI/128)));
          const r = 0.6; // 弧线半径
          const xs=[], ys=[];
          for (let i=0;i<=steps;i++) { const t = a1 + dAng * (i/steps); xs.push(r*Math.cos(t)); ys.push(r*Math.sin(t)); }
          traces.push({ x:[0, uI.x*r], y:[0, uI.y*r], mode:'lines', type:'scatter', name:'理想方向', line:{width:1.5, color:'rgba(231,76,60,0.85)'}, hoverinfo:'skip' });
          traces.push({ x:[0, uC.x*r], y:[0, uC.y*r], mode:'lines', type:'scatter', name:'比较方向', line:{width:1.5, color:'rgba(148,103,189,0.85)'}, hoverinfo:'skip' });
          traces.push({ x:xs, y:ys, mode:'lines', type:'scatter', name:'夹角', line:{width:2, color:'rgba(52,152,219,0.8)', dash:'dot'}, hoverinfo:'skip' });
        }
      }
      return traces;
    }

    function pickCustomerFromPoint(pt) {
      const x = pt.x, y = pt.y;
      // 找到最近的客户点
      let best = null, bestd = Infinity;
      for (const c of CUSTOMERS) {
        const d = Math.hypot(c.x - x, c.y - y);
        if (d < bestd) { best = c; bestd = d; }
      }
      if (best && bestd < 0.05) state.selectedId = best.id; // 距离阈值，避免误选
      else state.selectedId = null;
    }

    function attachPlotEvents() {
      const plot = document.getElementById('scatter');
      plot.on('plotly_click', (ev) => {
        if (!ev || !ev.points || ev.points.length === 0) return;
        const p = ev.points[0];
        if (p && p.data && p.data.name === '客户') {
          state.selectedId = CUSTOMERS[p.pointNumber].id;
          draw();
        } else {
          // 非客户点击则采用近邻挑选策略（容错）
          pickCustomerFromPoint(p);
          draw();
        }
      });
      plot.on('plotly_relayout', (ev) => {
        if (!ev) return;
        const hasX = Object.prototype.hasOwnProperty.call(ev, 'annotations[0].x');
        const hasY = Object.prototype.hasOwnProperty.call(ev, 'annotations[0].y');
        if (hasX || hasY) {
          state.ideal.x = hasX ? ev['annotations[0].x'] : state.ideal.x;
          state.ideal.y = hasY ? ev['annotations[0].y'] : state.ideal.y;
          draw();
        }
      });
    }

    function init() {
      UI.metric.value = state.metric;
      UI.metric.addEventListener('change', () => { state.metric = UI.metric.value; draw(); });
      UI.minkowskiP.value = state.minkowskiP;
      UI.minkowskiP.addEventListener('input', () => { state.minkowskiP = parseFloat(UI.minkowskiP.value)||3; UI.pBadge.textContent = state.minkowskiP.toFixed(1); draw(); });
      UI.showIso.checked = state.showIso;
      UI.showIso.addEventListener('change', () => { state.showIso = UI.showIso.checked; draw(); });
      draw();
      attachPlotEvents();
      window.addEventListener('resize', () => { Plotly.Plots.resize('scatter'); });
    }

    init();
  </script>
</body>
</html>


