<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>梯度下降：下山之旅（手动/自动）</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'Liberation Sans', sans-serif; margin: 0; }
    .wrap { max-width: 1200px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 20px; margin: 0 0 8px; }
    .sub { color:#555; margin-bottom: 14px; font-size: 14px; }
    .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; align-items: center; }
    .ctrl { background: #f7f7f9; border: 1px solid #e3e3e7; border-radius: 10px; padding: 10px 12px; }
    .ctrl label { display: block; font-size: 13px; color: #333; margin-bottom: 6px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    input[type=range] { width: 240px; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 999px; background: #eef; border: 1px solid #ccf; font-size: 12px; }
    .btn { padding: 8px 12px; border-radius: 8px; border: 1px solid #e3e3e7; background: white; cursor: pointer; }
    .btn.primary { background: #2b6cb0; color: white; border-color: #2b6cb0; }
    .btn:disabled { opacity: .6; cursor: not-allowed; }
    .stats { font-size: 13px; color: #333; }
    .row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 14px; }
    #curve { width: 100%; height: 520px; }
    #loss { width: 100%; height: 250px; }
    @media (max-width: 900px) { .row2 { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>梯度下降：下山之旅（手动/自动）</h1>
    <div class="sub">目标函数：<code>f(x) = 0.25\,(x^2 - 1)^2 + 0.05\,x</code>（双井非凸且略带倾斜）。调整学习率与初始位置，单步或自动沿负梯度方向更新：<code>x ← x - η · ∇f(x)</code>，始终在原始函数曲线之上叠加显示下降轨迹。</div>

    <div class="controls">
      <div class="ctrl">
        <label>学习率 η：<span id="lrBadge" class="badge"></span></label>
        <div class="row"><input id="lr" type="range" min="0" max="1" step="0.001"></div>
      </div>
      <div class="ctrl">
        <label>初始 x₀：<span id="x0Badge" class="badge"></span></label>
        <div class="row"><input id="x0" type="range" min="-5" max="5" step="0.01"></div>
      </div>
      <div class="ctrl">
        <label>自动速度（步/秒）：<span id="speedBadge" class="badge"></span></label>
        <div class="row">
          <input id="speed" type="range" min="0" max="120" step="1">
          <button id="toggle" class="btn primary">开始模拟</button>
          <button id="step" class="btn">单步</button>
          <button id="reset" class="btn">重置</button>
        </div>
      </div>
      <div class="ctrl">
        <label>当前统计</label>
        <div class="row"><div id="stats" class="stats"></div></div>
      </div>
    </div>

    <div class="row2">
      <div id="curve"></div>
      <div id="loss"></div>
    </div>
  </div>

  <script>
    const UI = {
      lr: document.getElementById('lr'),
      x0: document.getElementById('x0'),
      speed: document.getElementById('speed'),
      lrBadge: document.getElementById('lrBadge'),
      x0Badge: document.getElementById('x0Badge'),
      speedBadge: document.getElementById('speedBadge'),
      toggle: document.getElementById('toggle'),
      step: document.getElementById('step'),
      reset: document.getElementById('reset'),
      stats: document.getElementById('stats'),
    };

    // 目标函数与梯度（更复杂：双井非凸 + 轻微线性倾斜）
    function f(x) {
      const x2 = x*x;
      return 0.25 * (x2 - 1) * (x2 - 1) + 0.05 * x;
    }
    function grad(x) {
      // df/dx = x*(x^2 - 1) + 0.05
      return x * (x*x - 1) + 0.05;
    }

    const state = {
      lr: 0.10,
      speed: 30,   // 步/秒
      tickMs: 50,
      carry: 0,
      t: 0,
      x: 3.00,
      historyX: [],
      historyY: [],
      timer: null,
      xRange: [-6, 6],
      yMin: -1,
      yMax: 20
    };

    function fmt(x, k=3) { return (Math.abs(x) < 1e-9 ? 0 : x).toFixed(k); }

    function updateBadges() {
      UI.lrBadge.textContent = state.lr.toFixed(3);
      UI.x0Badge.textContent = fmt(state.x, 2);
      UI.speedBadge.textContent = state.speed.toString();
    }

    function updateStats() {
      const g = grad(state.x);
      UI.stats.textContent = `t = ${state.t} ｜ x = ${fmt(state.x,4)} ｜ f(x) = ${fmt(f(state.x),4)} ｜ ∇f = ${fmt(g,4)} ｜ 下一步：x - η∇f = ${fmt(state.x - state.lr*g,4)}`;
    }

    // 曲线图
    let curveInitialized = false;
    function drawCurve(reset=false) {
      // 基准曲线
      const xs = [];
      const ys = [];
      const [xmin, xmax] = state.xRange;
      const N = 400;
      for (let i=0;i<=N;i++) {
        const x = xmin + (xmax - xmin) * (i/N);
        xs.push(x);
        ys.push(f(x));
      }
      // 根据采样动态计算 y 轴范围并留白
      let yMin = Math.min(...ys);
      let yMax = Math.max(...ys);
      const pad = Math.max(0.5, (yMax - yMin) * 0.08);
      state.yMin = yMin - pad;
      state.yMax = yMax + pad;

      const current = { x: [state.x], y: [f(state.x)], mode: 'markers', type: 'scatter', name: '当前位置', marker: { size: 10, color: '#e74c3c', line: {width: 0.5, color: '#333'} } };
      const traj = { x: state.historyX.slice(), y: state.historyY.slice(), mode: 'lines', type: 'scatter', name: '轨迹', line: { width: 2, color: '#2ca02c' } };

      const nextX = state.x - state.lr * grad(state.x);
      const arrow = { x: [state.x, nextX], y: [f(state.x), f(nextX)], mode: 'lines+markers', type: 'scatter', name: '更新方向', line: { width: 1.5, dash: 'dot', color: '#9467bd' }, marker: { size: 4, color: '#9467bd' } };

      const base = { x: xs, y: ys, mode: 'lines', type: 'scatter', name: 'f(x)=0.25(x^2-1)^2+0.05x', line: { width: 2, color: '#1f77b4' } };

      const layout = {
        title: '目标曲线与下降轨迹',
        xaxis: { title: 'x', range: state.xRange, zeroline: false },
        yaxis: { title: 'f(x)', range: [state.yMin, state.yMax], zeroline: false },
        margin: { l: 60, r: 20, t: 40, b: 40 },
        shapes: [
          { type: 'line', x0: 0, x1: 0, y0: state.yMin, y1: state.yMax, line: { color: 'rgba(0,0,0,0.25)', width: 1, dash: 'dash' } },
          { type: 'line', x0: state.xRange[0], x1: state.xRange[1], y0: 0, y1: 0, line: { color: 'rgba(0,0,0,0.25)', width: 1, dash: 'dash' } },
        ]
      };

      const data = [base, traj, current, arrow];
      if (!curveInitialized || reset) {
        Plotly.react('curve', data, layout, {displayModeBar:false});
        curveInitialized = true;
      } else {
        Plotly.react('curve', data, layout, {displayModeBar:false});
      }
    }

    function updateCurveDynamic() {
      const nextX = state.x - state.lr * grad(state.x);
      Plotly.restyle('curve', {
        x: [null, state.historyX, [state.x], [ [state.x, nextX] ]],
        y: [null, state.historyY, [f(state.x)], [ [f(state.x), f(nextX)] ]]
      });

      // 如当前值越界，则扩展 y 轴范围（上下）
      const yNow = f(state.x);
      if (yNow > state.yMax * 0.98) {
        const grow = Math.max(0.5, (yNow - state.yMax) * 1.2);
        state.yMax = Math.min(1e6, yNow + grow);
        Plotly.relayout('curve', { 'yaxis.range': [state.yMin, state.yMax] });
      } else if (yNow < state.yMin * 0.98) {
        const grow = Math.max(0.5, (state.yMin - yNow) * 1.2);
        state.yMin = yNow - grow;
        Plotly.relayout('curve', { 'yaxis.range': [state.yMin, state.yMax] });
      }

      // 如果 x 超出范围，则扩展 x 轴与基准曲线
      if (state.x < state.xRange[0] + 0.5 || state.x > state.xRange[1] - 0.5) {
        const span = state.xRange[1] - state.xRange[0];
        const cx = Math.max(Math.abs(state.x), Math.abs(state.xRange[1]));
        const newMax = Math.max(6, Math.ceil(cx + span * 0.5));
        state.xRange = [-newMax, newMax];
        drawCurve(false); // 重新绘制基准曲线（保持原始函数曲线可见）
      }
    }

    // 损失图
    let lossInitialized = false;
    function drawLoss(reset=false) {
      const data = [ { x: [], y: [], mode: 'lines', type: 'scatter', name: 'f(x)', line: { width: 2, color: '#d62728' } } ];
      const layout = {
        title: '迭代收敛曲线',
        xaxis: { title: '步数 t', rangemode:'tozero' },
        yaxis: { title: 'f(x)', rangemode:'tozero' },
        margin: { l: 60, r: 20, t: 40, b: 40 }
      };
      Plotly.react('loss', data, layout, {displayModeBar:false});
      lossInitialized = true;
    }

    function extendLossPoint() {
      Plotly.extendTraces('loss', { x: [[state.t]], y: [[f(state.x)]] }, [0], 2000);
    }

    // 仿真控制
    function stepOnce() {
      const g = grad(state.x);
      const xNext = state.x - state.lr * g;
      state.t += 1;
      state.x = xNext;
      state.historyX.push(state.x);
      state.historyY.push(f(state.x));
      extendLossPoint();
      updateCurveDynamic();
      updateStats();
    }

    function tick() {
      const stepsExact = state.speed * state.tickMs / 1000 + state.carry;
      const steps = Math.floor(stepsExact);
      state.carry = stepsExact - steps;
      if (steps <= 0) return;
      for (let i=0;i<steps;i++) stepOnce();
    }

    function start() {
      if (state.timer) return;
      state.timer = setInterval(tick, state.tickMs);
      UI.toggle.textContent = '暂停';
    }

    function stop() {
      if (!state.timer) return;
      clearInterval(state.timer);
      state.timer = null;
      UI.toggle.textContent = '开始模拟';
    }

    function reset(keepParams=false) {
      stop();
      state.t = 0;
      if (!keepParams) {
        state.x = parseFloat(UI.x0.value) || 0;
      }
      state.historyX = [state.x];
      state.historyY = [f(state.x)];
      state.xRange = [-6, 6];
      drawCurve(true);
      drawLoss(true);
      extendLossPoint();
      updateBadges();
      updateStats();
    }

    function init() {
      // 初始值
      UI.lr.value = state.lr;
      UI.x0.value = state.x;
      UI.speed.value = state.speed;
      updateBadges();
      reset(true);

      // 事件
      UI.lr.addEventListener('input', () => {
        state.lr = parseFloat(UI.lr.value) || 0;
        updateBadges();
        updateCurveDynamic();
        updateStats();
      });
      UI.x0.addEventListener('input', () => {
        state.x = parseFloat(UI.x0.value) || 0;
        reset(true); // 根据新的初值重置轨迹
      });
      UI.speed.addEventListener('input', () => {
        state.speed = parseInt(UI.speed.value, 10) || 0;
        updateBadges();
      });
      UI.toggle.addEventListener('click', () => { if (state.timer) stop(); else start(); });
      UI.step.addEventListener('click', stepOnce);
      UI.reset.addEventListener('click', () => reset(false));
      window.addEventListener('resize', () => { Plotly.Plots.resize('curve'); Plotly.Plots.resize('loss'); });
    }

    init();
  </script>
</body>
</html>


