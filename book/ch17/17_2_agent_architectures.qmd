---
title: "17.2 架构师的蓝图：主流智能体架构模式"
---

要将“数字员工”从概念变为现实，我们需要超越单一的指令-响应循环。就像建立一家公司需要设计组织架构一样，构建复杂的智能体系统，也需要清晰的**架构模式**。

一个著名的早期智能体框架叫做 ReAct（Reasoning and Acting，思考与行动）。它通过让 LLM 在“思考（Thought）”和“行动（Action）”之间交替，实现简单的工具调用。你可以将 ReAct 看作是智能体最基本的“细胞”。但要构建一个能完成复杂任务的“生物体”，我们就需要将这些“细胞”组织起来，形成更宏大的结构。

作为系统架构师，我们需要掌握以下几种主流的、已经被业界广泛验证的智能体团队协作模式：

### 1. 单一智能体 + 工具 (Single Agent + Tools)

这是最基础的模式，也是 ReAct 框架的直接体现。一个“全才”智能体负责处理所有任务，它拥有一套预先定义好的工具箱。

- **工作方式**：接收用户请求 -> 思考需要哪个工具 -> 调用工具 -> 观察结果 -> 循环此过程直到任务完成。
- **适用场景**：目标明确、步骤直接的简单任务。例如，“今天上海的天气怎么样？”智能体只需调用天气查询工具即可。
- **好比**：一个随身带着瑞士军刀的个人助理。

```{mermaid}
graph TD
    A[用户请求] --> B{单一智能体};
    B -- 思考 --> C[工具箱: 天气API, 计算器, ...];
    C -- 行动 --> B;
    B --> D[最终答案];
```

### 2. 路由智能体 (Router / Dispatcher Agent)

当任务类型多样，需要由不同的“专家”来处理时，路由模式就派上了用场。一个“总机”或“分发员”智能体负责将任务分配给最合适的下游智能体或工具。

- **工作方式**：接收用户请求 -> 分析请求意图 -> 将请求**路由**给最合适的专家智能体。
- **适用场景**：需要根据输入类型选择不同处理路径的场景。例如，一个客服平台，可以根据用户是想“查询订单”还是“投诉建议”，将其分发给“订单查询智能体”或“客户关系智能体”。
- **好比**：公司的前台总机，负责将电话转接到正确的部门。

```{mermaid}
graph TD
    A[用户请求] --> B{路由智能体};
    B -- "意图: 查订单" --> C[订单处理专家];
    B -- "意图: 写代码" --> D[代码生成专家];
    B -- "意图: 聊天" --> E[闲聊专家];
    C --> F[完成];
    D --> F;
    E --> F;
```

### 3. 顺序智能体流 (Sequential Agents / "Pipeline")

对于流程固化的多阶段任务，我们可以设计一条“流水线”，让多个“专才”智能体按固定顺序接力完成工作。

- **工作方式**：任务从第一个智能体开始，处理完成后，其输出会作为下一个智能体的输入，依次传递，直到最后一个智能体完成全部工作。
- **适用场景**：流程高度固化、步骤清晰的工作。例如，一份“自动化市场分析报告”的生成流程：
    1.  **数据抓取智能体**：从指定网站抓取原始数据。
    2.  **数据清洗智能体**：清洗并格式化数据。
    3.  **数据分析智能体**：进行统计分析和可视化。
    4.  **报告撰写智能体**：将分析结果整合成一份完整的报告。
- **好比**：工厂里的生产流水线。

```{mermaid}
graph LR
    A[开始] --> B[智能体 A: 抓取];
    B --> C[智能体 B: 清洗];
    C --> D[智能体 C: 分析];
    D --> E[智能体 D: 撰写];
    E --> F[结束];
```

### 4. 层次化智能体 (Hierarchical Agents / "Manager-Worker")

这是目前最强大、最灵活的架构之一，尤其适用于需要动态规划和协作的复杂、开放式任务。该模式中，一个“总管”智能体负责任务的整体规划、分解和监督，并将子任务分配给下属的“员工”智能体去执行。

- **工作方式**：
    1.  “总管”接收复杂目标，进行**任务分解 (Task Decomposition)**，形成一个计划。
    2.  “总管”将计划中的第一个子任务分配给一个或多个合适的“员工”。
    3.  “员工”执行任务，并将结果汇报给“总管”。
    4.  “总管”根据执行结果，**反思 (Reflection)** 并更新计划，然后继续分配下一个任务，直到最终目标达成。
- **适用场景**：几乎所有复杂的、可以被清晰分解的开放式任务。例如，完成用户“帮我策划一次为期五天的北京家庭旅行”的请求。总管可以分解出“查询往返机票”、“预订酒店”、“规划每日行程”、“查找特色餐厅”等子任务，并分配给不同的员工智能体。
- **好比**：一个项目经理（总管）带领一个工程师团队（员工）。

```{mermaid}
graph TD
    subgraph "智能体团队"
        A[总管智能体]
        B[员工A: 机票专家]
        C[员工B: 酒店专家]
        D[员工C: 行程规划专家]
    end
    
    U[用户: "策划北京五日游"] --> A;
    A -- "1. 规划 & 分解" --> A;
    A -- "2. 分配: 查机票" --> B;
    B -- "3. 执行 & 汇报" --> A;
    A -- "4. 分配: 订酒店" --> C;
    C -- "5. 执行 & 汇报" --> A;
    A -- "6. 分配: 定行程" --> D;
    D -- "7. 执行 & 汇报" --> A;
    A -- "8. 整合 & 输出" --> F[最终旅行计划];
```

作为架构师，理解这些模式的优劣和适用场景至关重要。在实际应用中，我们常常会将这些模式组合起来，形成一个混合架构，以应对真实世界中错综复杂的业务需求。在接下来的章节中，我们将学习如何使用 LangGraph 这个强大的工具，来实现这些复杂的智能体架构。

::: {.callout-tip}
### Vibe Coding 提示
现在，请打开你的 AI 编程助手，尝试向它发出这样的指令：

> “请为我之前学习的四种智能体架构模式——单一智能体、路由智能体、顺序智能体流、层次化智能体——分别再补充一个你认为最贴切的商业应用案例，并解释为什么这个案例适合该架构。”

观察 AI 助手的回答，这能帮助你更深入地理解每种架构的精髓。
:::

