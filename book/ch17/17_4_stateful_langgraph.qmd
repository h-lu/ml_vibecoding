---
title: "17.4 用 LangGraph 构建“有状态”的智能体"
---

理论知识已经铺垫完毕，现在让我们进入实践环节。要构建我们在 17.2 节中设想的那些强大、可靠的智能体架构，我们需要一个与之匹配的、工业级的开发框架。

在 LangChain 的早期版本中，最常用的智能体执行器是 `AgentExecutor`。它将 ReAct 循环封装成一个易于调用的黑盒。这对于快速验证想法非常方便，但当面临真正复杂的、需要高可靠性的业务流程时，它的局限性就暴露无遗：

-   **无状态 (Stateless)**：`AgentExecutor` 本质上是一个“无状态”的循环。它只关心“上一步”和“下一步”，很难追踪和管理一个贯穿任务全程的、统一的状态。
-   **控制流有限 (Limited Control Flow)**：在它的黑盒循环里，我们很难实现复杂的控制逻辑，比如“如果 A 工具失败了，就去尝试 B 工具”，或者“当满足某个条件时，跳回到第三步重新执行”。
-   **难以调试 (Hard to Debug)**：由于是黑盒，当智能体行为不符合预期时，我们很难看清楚它内部到底发生了什么，到底是哪个环节出了问题。

为了解决这些生产环境中的核心痛点，LangChain 团队推出了革命性的新框架：**LangGraph**。

### LangGraph 的革命：将工作流定义为“图”

LangGraph 的核心思想非常优雅：**它不再将智能体的工作流看作一个线性的、神秘的循环，而是将其显式地定义为一个有向图 (Directed Graph)。**

在这个图中：

-   **状态 (State)**：有一个全局的、贯穿始终的状态对象。它是一个自定义的数据结构（通常是一个 Python 的 `TypedDict`），记录了工作流执行至今的所有关键信息。
-   **节点 (Nodes)**：代表了工作流中的一个具体“步骤”。一个节点可以是一个调用 LLM 的函数，也可以是一个执行工具的函数，甚至是另一个子图（Sub-Graph）。每个节点都接收当前的状态作为输入，并返回一个更新后的状态。
-   **边 (Edges)**：负责连接节点，定义了工作流的“流向”。边决定了在一个节点执行完毕后，接下来应该去往哪个节点。

```{mermaid}
graph TD
    A[开始] --> B(节点1: 分析需求);
    B -- "边" --> C(节点2: 调用工具);
    C -- "边" --> D(节点3: 总结结果);
    D --> E[结束];

    subgraph "工作流图 (Graph)"
        direction LR
        B
        C
        D
    end
    
    S[(状态对象<br>State)] -- "在图中流动和更新" --> B;
    B -- "更新" --> S;
    S --> C;
    C -- "更新" --> S;
    S --> D;
```

### 杀手级特性：条件边 (Conditional Edges)

如果说将工作流图化是 LangGraph 的骨架，那么**条件边**就是它的神经网络，赋予了它真正的智能。

LangGraph 允许我们定义一种特殊的“条件边”。在一个节点执行完毕后，我们可以通过一个路由函数 (Routing Function) 来检查当前**状态 (State)** 的内容，然后**动态地决定**工作流的下一步应该走向哪个节点。

这意味着什么？这意味着我们可以在图中轻松实现所有经典的程序控制流：

-   **分支 (Branching)**：`if-else` 逻辑。例如，如果状态显示“金额小于500”，则走向“直接批准”节点；否则，走向“需要经理审批”节点。
-   **循环 (Looping)**：`while` 或 `for` 逻辑。例如，只要状态显示“任务未完成”，就一直循环“思考 -> 行动”这个子流程。
-   **并行 (Parallelism)**：可以同时将任务分发给多个节点并行处理。
-   **回退与重试 (Fallback & Retry)**：可以轻松实现“如果A节点失败，则跳转到B节点重试”的容错逻辑。

这种对工作流的**显式、精细化控制**，正是构建严肃、可靠、可维护的企业级 AI 应用所必需的。LangGraph 将智能体从一个“凭感觉”运行的黑盒，变成了一个逻辑清晰、行为可预测、过程可追溯的“白盒”系统。

::: {.callout-tip}
### Vibe Coding 提示

请向你的 AI 编程助手提问：

> "请用一个具体的例子，对比 LangChain 的 `AgentExecutor` 和 `LangGraph`。假设我想实现一个‘先尝试用 Google 搜索答案，如果搜索结果为空，则再尝试用 DuckDuckGo 搜索’的容错逻辑。请解释为什么用 `LangGraph` 实现这个逻辑会比用 `AgentExecutor` 更简单、更清晰。"

通过这个问题，你可以非常直观地感受到 LangGraph 在控制流上的巨大优势。
:::

